
\chapter{Polynomial arithmetic}
\label{polynomials}

FORM has several approaches to the treatment of polynomials. First there is 
of course the standard way of seeing a complete expression that consists 
only of symbols as a multivariate polynomial. This is of course the direct 
approach and needs no special treatment. Starting with version two the 
concept of the PolyFun or polynomial function was introduced. This function 
allowed its argument to take the place of the coefficient of the term. This 
way whole polynomials could take such a role and be hidden from the regular 
pattern matching, allowing great savings in time. Yet this was not 
sufficient for many calculations.

When solving complicated systems of equations in which the coefficients are 
polynomials in one or more variables, the need arises to manipulate these 
polynomials in a more sophisticated way. As a first study of this problem, 
the earlier subversions of version 3 of FORM were equipped with new 
functions like PolyDiv\_, PolyGCD\_ etc. that provided some rudimentary 
(and very slow) ways to perform basic operations on polynomials that are 
either presented in the form of regular expressions or \$-expressions. As 
this wasn't enough for some people the connection with external programs 
was established (see chapter \ref{externalcommunication}) to allow the user 
to employ the facilities of systems that have good implementations for the 
treatment of commands that are not present in FORM. The advantage of this 
is that such systems are usually maintained by people who are specialists 
in certain fields and hence can make sure that the latest and best 
algorithms are implemented. The limited manpower available for the 
development of FORM doesn't always permit this.

The alternative to using the external channels for polynomial manipulations 
is to implement one of the libraries that are freely available. This would 
be the best approach because this could mean that some expert will be 
responsible for the maintenance and further development of such a library. 
In the case of multiple precision arithmetic this is a decent approach and 
hence recently (Oct-2007) some of the low level routines of the GMP library 
have been hooked up to FORM. In doing this the main problem is the 
conversion of internal notations and hence these routines are only used 
when the size of the numbers is greater than some minimal value. The high 
level routines are not so useful in this context as they don't add much and 
actually introduce more problems than they solve (like with memory 
management). This could be the same with libraries for the manipulation of 
(rational) polynomials. Hence our current approach is to install a 
reasonbly efficient system of our own makings that agrees very well with 
the special properties of FORM and then at a later moment replace just the 
low level routines by those of the most efficient library that is generally 
available. Here it should be mentioned that most libraries only deal with 
the case of polynomials in a single variable, which means necessarily 
objects of a rather limited size, while in FORM we are often interested in 
multivariate objects of an uncontroled size. Again this will present memory 
management problems. When we need polynomials in a single variable we often 
need many millions of them (and in the future many billions) and hence 
uncontroled use of the memory assignment functions (malloc) may eventually 
cause bad memory fragmentation problems. Hence great care is needed here.

At the moment we aim for a threefold approach. We use `small' polynomials 
which fit inside the argument of a function and we use `big' polynomials 
which are essentially whole expressions. For intermediate manipulations we 
can use the \$-variables. The memory management of the small polynomials 
takes place in the WorkSpace only. The \$-variables use the memory 
allocator of C library cq. the operating system. The expressions use the 
FORM memory management that may involve the disk.

The first application of the `small' polynomials is the introduction of the 
PolyRatFun. This is a function like the PolyFun, but it uses two arguments 
which are taking the role of a numerator and a denominator. Hence their 
arguemnts represent a rational polynomial. There are some restrictions to 
the use of this function. The PolyRatFun can only have symbols and numbers 
in its arguments. Any other objects (like functions, tensors, vectors or 
indices) will eventually lead to a runtime error. The reason is that the 
polynomial functions allow, for the sake of speed, only manipulate numbers 
and symbols. One can of course replace each different function (or function 
with a different argument) temporarily by a different symbol, but this is 
left to the user.

One reason that the PolyFun and the PolyRatFun are treated separately is 
that when one uses the PolyFun it is often for power expansions in which 
the ordering of the terms is such that the lowest powers come first. In the 
PolyRatFun nearly all algorithms require the highest powers to come first 
and hence we enforce a different ordering there. 
