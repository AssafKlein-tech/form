[19feb2004 mt]:
After introducing a differentiation in PARALLEL modes, sometimes extra 
warnings in sequential mode occur. To prevent such warnins I inserted
#ifdef PARALLEL in execute.c.

[19mar2004 mt]:
Large file support  is repaired (it was broken!), see comments in the file 
declare.h

[05apr2004 mt] - [07apr2004 mt] New directive:
cleartable thetable;
removes an existing table. If there is no such a table, the warning is generated:
"should be a table! -- Ignored".
And, [07apr2004 mt] -- memory leak is fixed in names.c:ResetVariables.

[28apr2004 mt]: 
signals SIGSEGV SIGFPE SIGILL SIGEMT SIGSYS SIGPIPE
SIGLOST SIGXCPU SIGXFSZ SIGTERM SIGINT SIGHUP SIGALRM SIGVTALRM
SIGPROF are captured in order to invoke Terminate(-1) on these signals.
To allow it at compile time, a macro
#define TRAPSIGNALS
should be defined in the file unix.h

[14apr2004 mt] - [27jul2004 mt] A new mechanism:
A new mechanism of interaction with external commands is implemented,
see an example below.

To allow the mechanism at compile time, a macro
#define WITHEXTERNALCHANNEL
should be defined in the file unix.h

INTRODUCTION

The preprocessor directives #system and #pipe execute the external
command synchronously i.e. they wait for the command to be completed.

The new directive #external starts the external command opening an
input-output channel for it, and can be used in order to extend FORM
in the spirit of a component model.

After the directive #external returns the control to the FORM program,
the external program initiated by the directive continues to run. Its
standard input and output references are stored by FORM. Both input
and output are not connected with any terminal device.

The directive #rmexternal terminates the external program. It
closes the programs' IO channels, sends to the program a KILL
signal and waits for the external program to be finished.                

The directive #toexternal is used to send some text to the running 
external program, the synthax is similar to the #write directive.

The directive #fromexternal is used to read the text from the running
external program, the synthax is similar to the #include directive.
FORM continues to read the running external program output until the
extrenal program outputs a prompt.

The prompt is the line consisting of a single string. By default, this
is an empty string.  The prompt can be changed by means of the
directive #prompt

THE EXACT SYNTHAX

#external ["prevar"] command
starts command in the background, swallowing its standard input and
output. The external program has no controlling terminal, the stderr
is redirected to /dev/null, the program becomes the leader of the new
session and the process group leader of the new process.

The optional parameter "prevar" is the (quoted) name of the
preprocessor variables. If it is present, "descriptor" (small positive
integer number) of the external command is stored into this variable
and can be used for referencies to this external program (if there are
more than one external program running simultaneously).

The last started external program becomes the "current" (active)
external program.  All further directives #fromexternal and
#toexternal deal with the current external program.

#toexternal "formatstring" [,variables]
sends the output to the current external program. The semantics of
"formatstring" [,variables] is the same as for the #write directive,
except the trailing end-of-line symbol: in contrast to the #write
directive, the #toexternal directive does not append any new line
symbol to the end of the format string.

#fromexternal appends the output of the current external program to
the FORM program.  The semantics is similar to the #include
directive. Folders are not supported. After the external program sends
the prompt, the input stream returns back to the current file
(containing the #fromexternal directive).  The prompt string is not
appended.

The prompt is the line consisting of a single string. By default, this
is an empty string.  The prompt can be changed by means of the
directive #prompt:

#prompt [newprompt]
Sets a new prompt for the current external program (if present) and
all further (newly started) external programs.

If newprompt is an empty string, the default prompt (the empty line) 
will be used.

#setexternal n
where n is the positive integer -- sets the "current" external
program.  Directives #toexternal and #fromexternal deal with the
"current" external program.  The number is the descriptor of the
running external program.

#rmexternal [n]
terminates the external program. n must be the descriptor of one of
the running external programs, or 0.

If n is 0, then all external pograms will be terminated.

If n is not specified, the current external program will be terminated.

The directive closes the programs' IO channels, sends a KILL signal to
every process in its process group and waits for the external program
to be finished.

The example:

s a,b;

#external "n1" cat

#external "n2" cat

*cat simply repeats its input. The default prompt is an empty line.
*So we use "\n\n" here -- one "\n" is to finish the line, and the next "\n"
*is the prompt:
#toexternal "(a+b)^2\n\n"

#setexternal `n1'
*For this channel the prompt will be "READY\n":
#toexternal "(a+b)^3\nREADY\n"

#setexternal `n2'
*Set the default prompt:
#prompt
l aPLUSbTO2=
#fromexternal
 ;

#setexternal `n1'
#prompt READY
l aPLUSbTO3=
#fromexternal
 ;

#rmexternal `n1'
#rmexternal `n2'

print;
.end

The low-level code is placed into a new file extcmd.c, see comments in
the beginning of the file extcmd.c.

PARALLEL MODE

In parallel mode, the external program is started and killed only by
the master.  The master writes to external channel, slaves just ignore
these operations.  The master reads the answer from the external
program and broadcasts it to slaves.

All switches concerning the parallel mode are made at a low level, in
the file extcmd.c.

[29jul2004 mt]:
Support of pipes in parallel mode temporary switched off.
