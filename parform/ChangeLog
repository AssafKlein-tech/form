30 January 2004 Mikhail Tentyukov:

Here I summarize all changes I have made before this date.
All the code fragments I removed are encased in 
#ifdef REMOVEDBY_MT
...
#endif
All my changes are enclosed with marks 
[date mt]:
...
:[date mt]
e.g.
   /*[25nov2003 mt]:*/
   /* PF_outterms++;*/
   PF.goutterms++;
   /*:[25nov2003 mt]*/

The most important:

[17sep2003 mt]: Bugfix: on/off parallel takes effect only starting from the 
next module. The reason: flag AC.mparallelflag was set according to 
AC.parallelflag in the function IniModule. The solution: see comments 
[17sep2003 mt] in functions CoOff and CoOn, file compcomm.c

[05nov2003 mt]: Bugfix: after some expression was processed in parallel, 
there is no possibility to compile module with another expression. The reason:
after a flag PF.parallel is set to 1, functions  FlushOut and PutOut in slaves 
invoked at compile time send a mess to the master. The solution: PF.parallel=0
in IniModule, see pre.c

[06nov2003 mt]: To allow usage of RHS expressions I force ParFORM to switch to
sequential execution of moduli with RHS expressions. I introduced a counter 
AC.NumberOfRhsExprInModule which counts hom many times RHS expressions occur.
The counter is incremented in the function tokenize in the file token.c

[13nov2003 mt]: Bugfix: The function Processor worked incorrectly
with the following values of e->status:
UNHIDELEXPRESSION UNHIDEGEXPRESSION SKIPLEXPRESSION
SKIPGEXPRESSION HIDELEXPRESSION HIDEGEXPRESSION
see file proces.c

[18nov2003 mt]: 2 preprocessor variables are defined: 1) PARALLELTASK_ as
a process number, 0 is the master; 2) NPARALLELTASKS_ as a total
number of processes. These variables allow ParFORM to interact with
the operational system via #system and #pipe

[19nov2003 mt]: preprocessor variable is defined: CMODULE_ is a
current module number, starting from 1.

[26nov2003 mt]: bagfixes:
1) Broadcasting from MASTER to SLAVES of PreProcessor variables that
have changed is moved to the beginning of each block. The
corresponding procedure is PF_InitRedefinedPreVars in
parallel.c. Note, compilation is performed INDEPENDENTLY on
AC.mparallelflag, so No if(AC.mparallelflag==PARALLELFLAG)!
ATTENTION! In the previous version there was an error! Variables must
be broadcasted independently on mparallelflag!!!  The procedure is
used to broadcast number of terms in expression for preprocessor
if-expression 'termsin',
2) Number of terms in the expression is broadcasted from the master
to slaves for preprocessor if-expression 'termsin'. The problem here
is that only the master process can decide how many terms the
expression contains. So we have to broadcast from master to all others
this value. The corresponding procedure PF_BroadcastNumberOfTerms
is in the file 'parallel.c'.

[28nov2003 mt]: if the environment variable PF_SYNC is set, the
beginning of each module will be synchronized compulsory. This is done
via invocation PF_InitRedefinedPreVars() even if AC.NumberOfRedefsInModule==0.
This feature is useful only for debugging.

[02dec2003]: Bagfix: the structure of attachment of PreProcessor variables that
have changed in slave was wrong, see strings 02dec2003 in parallel.c.

[12dec2003 mt] Preprocessor directives "addseparator" and
"rmseparator" adds/removes separator characters used to separate
function arguments.  Example
#define QQ "a|g|a"
#addseparator %
*Comma must be quoted!:
#rmseparator ","
#rmseparator |
#call H(a,a%`QQ')

[30jan2004 mt]
Conception of on/off parallel is changed: instead of two flags, PARALLELFLAG 
and NOPARLLELFALG, I introduce several bit falgs:

#define NOPARALLEL_DOLLAR 1
#define NOPARALLEL_STORE 2
#define NOPARALLEL_RHS 4
#define NOPARALLEL_MOPT 8
#define NOPARALLEL_USER 16 
#define NOPARALLEL_TBLDOLLAR 32
#define PARALLEL_MOPT 64

#define PARALLELFLAG 0

So, now the resaon why execution can't be done in parallel will be reported 
to the user.

*************** Start further ChangeLog *****************
[19feb2004 mt]:
After introducing a differentiation in PARALLEL modes, sometimes extra 
warnings in sequential mode occur. To prevent such warnins I inserted
#ifdef PARALLEL in execute.c.

[19mar2004 mt]:
Large file support  is repaired (it was broken!), see comments in the file 
declare.h

[05apr2004 mt] - [07apr2004 mt] New directive:
cleartable thetable;
removes an existing table. If there is no such a table, the warning is generated:
"should be a table! -- Ignored".
And, [07apr2004 mt] -- memory leak is fixed in names.c:ResetVariables.

[28apr2004 mt]: 
signals SIGSEGV SIGFPE SIGILL SIGEMT SIGSYS SIGPIPE
SIGLOST SIGXCPU SIGXFSZ SIGTERM SIGINT SIGHUP SIGALRM SIGVTALRM
SIGPROF are captured in order to invoke Terminate(-1) on these signals.
To allow it at compile time, a macro
#define TRAPSIGNALS
should be defined in the file unix.h

[14apr2004 mt] - [27jul2004 mt] A new mechanism:
A new mechanism of interaction with external commands is implemented,
see an example below.

To allow the mechanism at compile time, a macro
#define WITHEXTERNALCHANNEL
should be defined in the file unix.h

INTRODUCTION

The preprocessor directives #system and #pipe execute the external
command synchronously i.e. they wait for the command to be completed.

The new directive #external starts the external command opening an
input-output channel for it, and can be used in order to extend FORM
in the spirit of a component model.

After the directive #external returns the control to the FORM program,
the external program initiated by the directive continues to run. Its
standard input and output references are stored by FORM. Both input
and output are not connected with any terminal device.

The directive #rmexternal terminates the external program. It
closes the programs' IO channels, sends to the program a KILL
signal and waits for the external program to be finished.                

The directive #toexternal is used to send some text to the running 
external program, the synthax is similar to the #write directive.

The directive #fromexternal is used to read the text from the running
external program, the synthax is similar to the #include directive.
FORM continues to read the running external program output until the
extrenal program outputs a prompt.

The prompt is the line consisting of a single string. By default, this
is an empty string.  The prompt can be changed by means of the
directive #prompt

THE EXACT SYNTHAX

#external ["prevar"] command
starts command in the background, swallowing its standard input and
output. The external program has no controlling terminal, the stderr
is redirected to /dev/null, the program becomes the leader of the new
session and the process group leader of the new process.

The optional parameter "prevar" is the (quoted) name of the
preprocessor variables. If it is present, "descriptor" (small positive
integer number) of the external command is stored into this variable
and can be used for referencies to this external program (if there are
more than one external program running simultaneously).

The last started external program becomes the "current" (active)
external program.  All further directives #fromexternal and
#toexternal deal with the current external program.

#toexternal "formatstring" [,variables]
sends the output to the current external program. The semantics of
"formatstring" [,variables] is the same as for the #write directive,
except the trailing end-of-line symbol: in contrast to the #write
directive, the #toexternal directive does not append any new line
symbol to the end of the format string.

#fromexternal appends the output of the current external program to
the FORM program.  The semantics is similar to the #include
directive. Folders are not supported. After the external program sends
the prompt, the input stream returns back to the current file
(containing the #fromexternal directive).  The prompt string is not
appended.

The prompt is the line consisting of a single string. By default, this
is an empty string.  The prompt can be changed by means of the
directive #prompt:

#prompt [newprompt]
Sets a new prompt for the current external program (if present) and
all further (newly started) external programs.

If newprompt is an empty string, the default prompt (the empty line) 
will be used.

#setexternal n
where n is the positive integer -- sets the "current" external
program.  Directives #toexternal and #fromexternal deal with the
"current" external program.  The number is the descriptor of the
running external program.

#rmexternal [n]
terminates the external program. n must be the descriptor of one of
the running external programs, or 0.

If n is 0, then all external pograms will be terminated.

If n is not specified, the current external program will be terminated.

The directive closes the programs' IO channels, sends a KILL signal to
every process in its process group and waits for the external program
to be finished.

The example:

s a,b;

#external "n1" cat

#external "n2" cat

*cat simply repeats its input. The default prompt is an empty line.
*So we use "\n\n" here -- one "\n" is to finish the line, and the next "\n"
*is the prompt:
#toexternal "(a+b)^2\n\n"

#setexternal `n1'
*For this channel the prompt will be "READY\n":
#toexternal "(a+b)^3\nREADY\n"

#setexternal `n2'
*Set the default prompt:
#prompt
l aPLUSbTO2=
#fromexternal
 ;

#setexternal `n1'
#prompt READY
l aPLUSbTO3=
#fromexternal
 ;

#rmexternal `n1'
#rmexternal `n2'

print;
.end

The low-level code is placed into a new file extcmd.c, see comments in
the beginning of the file extcmd.c.

PARALLEL MODE

In parallel mode, the external program is started and killed only by
the master.  The master writes to external channel, slaves just ignore
these operations.  The master reads the answer from the external
program and broadcasts it to slaves.

All switches concerning the parallel mode are made at a low level, in
the file extcmd.c.

[29jul2004 mt]:
Support of pipes in parallel mode temporary switched off.

****** [13 jul 2005] new release ********

Minor bugfixes (_potential_ bugs), and:

1. UNDONE [05apr2004 mt] - [07apr2004 mt] New directive: cleartable thetable;
[07apr2004 mt] memory leak fix in names.c:ResetVariables is _not_ removed.

2. Checkup whether read()/write() syscalls are interrupted by a signal is
enclosed with #ifdef SAFESIGNAL

****** [15 sep 2005] intermediate release for synchronization ********
[14sep2005 mt]:
Bugfix (in proces.c:Generator): in "off parallel", the master itself must
collect preprovars.

****** [09 oct 2005]  intermediate release for synchronization ********

1. Preprocessor variables PARALLELTASK_ and NPARALLELTASKS_ are
defined even for sequential version: otherwise, it is too
difficult to run the same program in both parallel and seq.
modes:

   /*[20sep2005 mt]:*/
   /*Define preprocessor variable PARALLELTASK_ as 0:*/
   PutPreVar((UBYTE *)"PARALLELTASK_",(UBYTE *)"0",0,0);
   /*Define preprocessor variable NPARALLELTASKS_ as 1:*/
   PutPreVar((UBYTE *)"NPARALLELTASKS_",(UBYTE *)"1",0,0);
   /*:[20sep2005 mt]*/

2. Dollar variables for the parallel mode is re-written, but at the
moment is not finished. The code from execute.c:DoExecute() is
re-written completely and moved it to mkDollarsParallel() in
paralle.c.  MinDollar() and MaxDollar() in dollar.c newer worked, a
lot of bugs were fixed.

The problem is that sometimes dollar variables are longer than
PF_packbuf!  Especially, when slaves pack several dollarvars.  For
broadcasting dollarvars created at preprocessing time the problem is
solved, see PF_BroadcastPreDollar() in parallel.c: we split long
expressin into chunks, and broadcast each chunk independently.
mkDollarsParallel() in parallel.c should be changed, it fails if
dollarvars are not really short.

*********************** new release *************************************
The problem with dollar variables longer than
PF_packbuf is solved, see comments in the section "Long pack stuff:"
in mpi.c. !!NOT WIDELY TESTED!!

Some cleanup concerning declaration of PF_ - functions.
functonal variables  from extcmd and WriteFile.

[12oct2005 mt]: Some stuff is moved into another place
in the file mpi.c, and PF.packsize is removed and PF_packsize is used
instead. It is rather difficult to proper comment it, so not all these
changing are marked by "[12oct2005 mt]".

[08nov2005 mt:] Bugfix on the bugfix of 14sep2005 concerning collecting
preprovars by the master in "off parallel" mode.

*********************** new release *************************************
[06dec2005 mt]: bugfix in PF_markPotModDollars (PF_potModDollsN=-1, not 0!)

May 2006 mt: external channels are changed according to the paper
http://www.arxiv.org/abs/cs.SC/0604052
The file extcmd.c is re-written completely.
The file extcmd.c is formatted according to FORM conventions (leading 
tabs and folders).

The preprocessor instruction #fromexternal is extended:
#fromexternal[+|-] ["[$]varname",[maxlength]]
   appends the output of the current external command to the FORM
   program. The semantics differ depending on the optional
   arguments. After the external command sends the prompt, FORM will
   continue with a next line after the line containing the
   #fromexternal instruction. The prompt string is not appended. The
   optional + or - sign after the name has influence on the listing of
   the content.
#fromexternal[+|-]
   The semantics is similar to the #include
   instruction but folders are not supported. 
#fromexternal[+|-] "[$]varname"
   is used to read the text from the running external command into the
   preprocessor variable varname, or into the dollar variable $varname
   if the name of the variable starts with the dollar sign $.
#fromexternal[+|-] "[$]varname" maxlength
   is used to read the text from the running external command into the
   preprocessor (or dollar) variable varname. Only the first maxlength
   characters are stored.

The preprocessor instruction #setexternalattr list_of_attributes
sets attributes for  newly started external commands. Already
running external commands are not affected. The list of attributes
is a comma separated list of pairs attribute=value, e.g.:
#setexternalattr shell=noshell,kill=9,killall=false
Possible attributes are:
kill
   specifies the signal to be sent to the external command either
   before the termination of the FORM program or by the preprocessor
   instruction #rmexternal. By default this is 9 (SIGKILL). Number
   0 means that no signal will be sent.
killall
   Indicates whether the kill signal will be sent to the whole group
   or only to the initial process. Possible values are "true" and
   "false". By default, the kill signal will be sent to the whole
   group.
daemon
   Indicates whether the command should be "daemonized", i.e.  the
   initial process will be passed to the init process and will belong
   to the new process group in the new session.  Possible values are
   "true" and "false". By default, "true".
shell
   specifies which shell is used to run a command. By default this is
   "/bin/sh -c".  If set "shell=noshell", the command will be stared
   by the instruction #external directly but not in a subshell, so the
   command should be a name of the executable file rather than a
   system command. The instruction #external will duplicate the
   actions of the shell in searching for an executable file if the
   specified file name does not contain a slash (/) character.  The
   search path is the path specified in the environment by the PATH
   variable.  If this variable isn't specified, the default path
   "/bin:/usr/bin" is used.
stderr
   specifies a file to redirect the standard error stream to.  By
   default it is "/dev/null". "stderr=terminal" is set, the standard
   error stream is not redirected.
Only attributes that are explicitly mentioned are changed, all others
remain unchanged.

There is a possibility to start FORM from another program providing
one (or more) communication channels (see below). These channels will
be visible from a FORM program as "pre-opened" external channels
existing after FORM starts. In this case, the preprocessor variable
"PIPES_" is defined and is equal to the total number of the pre-opened
external channels.  Pre-opened external channel descriptors are
contained in the preprocessor variables "PIPE1_", "PIPE2_", etc.  The
corrsponding file descriptors are passed as a decimal number via the
environment variable FORM_PIPES or the command line option "-pipe";
the command line option overrides the environment variable. See the 
paper cs.SC/0604052 for detailes, or comments in extcmd.c just before
the function initPresetExternalChannels().

The prototype of the function openExternalChannel is changed.
getcFromExtChannelFailure() now returns -2 (formerly EOF) to 
distinguish between fault and normal EOF condition returned 
getcFromExtChannel()
